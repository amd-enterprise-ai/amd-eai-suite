# Copyright Â© Advanced Micro Devices, Inc., or its affiliates.
#
# SPDX-License-Identifier: MIT

*** Settings ***
Documentation       High-level workload testing keywords for AIRM.
...                 Provides business-logic level keywords for testing workload operations.
...                 Uses low-level kubectl and API keywords to implement higher-level testing scenarios.
Resource            kubectl_workloads.resource
Resource            kubectl_verification.resource
Resource            api/workloads.resource
Resource            api/common.resource
Resource            airm_projects.resource
Resource            airm_clusters.resource
Resource            common/resource_tracking.resource
Resource            common/resource_resolver.resource
Library             Collections
Library             String
Library             BuiltIn
Library             OperatingSystem


*** Variables ***
@{CREATED_WORKLOAD_IDS}         # List to track created workload IDs from AIRM API for cleanup
@{CREATED_HELM_RELEASES}        # List to track helm releases for cleanup
${TEST_WORKLOAD_CHART_PATH}     ${EMPTY}
${TEST_WORKLOAD_RELEASE_NAME}   ${EMPTY}
${TEST_WORKLOAD_ID}             ${EMPTY}
${TEST_NAMESPACE}               ${EMPTY}


*** Keywords ***
Initialize Workload Tracking
    [Documentation]    Resets the lists of created workloads and helm releases
    ...    Note: This extends the basic tracking from resource_tracking.resource
    ...    by also tracking helm releases
    Initialize Workload ID Tracking
    @{empty_releases}=    Create List
    Set Suite Variable    ${CREATED_HELM_RELEASES}    ${empty_releases}
    Log    Workload and helm release tracking initialized    DEBUG

# Given keywords - Setup and data preparation

A simple test workload is prepared
    [Documentation]    Prepares a simple test workload configuration
    ${unique_suffix}=    Generate Random String    6    [LOWER][NUMBERS]
    ${release_name}=    Set Variable    test-job-${unique_suffix}

    ${chart_path}=    Set Variable    ${CURDIR}/../test_workloads/simple-job

    Set Test Variable    ${TEST_WORKLOAD_RELEASE_NAME}    ${release_name}
    Set Test Variable    ${TEST_WORKLOAD_CHART_PATH}    ${chart_path}
    Set Test Variable    ${TEST_WORKLOAD_TYPE}    simple-job

A long-running workload is prepared
    [Documentation]    Prepares a long-running test workload configuration
    ${unique_suffix}=    Generate Random String    6    [LOWER][NUMBERS]
    ${release_name}=    Set Variable    test-longrun-${unique_suffix}

    ${chart_path}=    Set Variable    ${CURDIR}/../test_workloads/long-running

    Set Test Variable    ${TEST_WORKLOAD_RELEASE_NAME}    ${release_name}
    Set Test Variable    ${TEST_WORKLOAD_CHART_PATH}    ${chart_path}
    Set Test Variable    ${TEST_WORKLOAD_TYPE}    long-running

A failing workload is prepared
    [Documentation]    Prepares a workload that will fail intentionally
    ${unique_suffix}=    Generate Random String    6    [LOWER][NUMBERS]
    ${release_name}=    Set Variable    test-fail-${unique_suffix}

    ${chart_path}=    Set Variable    ${CURDIR}/../test_workloads/failing-job

    Set Test Variable    ${TEST_WORKLOAD_RELEASE_NAME}    ${release_name}
    Set Test Variable    ${TEST_WORKLOAD_CHART_PATH}    ${chart_path}
    Set Test Variable    ${TEST_WORKLOAD_TYPE}    failing-job

A workload with CPU quota "${cpu_limit}" is prepared
    [Documentation]    Prepares a workload with specific CPU resource requirements
    ${unique_suffix}=    Generate Random String    6    [LOWER][NUMBERS]
    ${release_name}=    Set Variable    test-cpu-${unique_suffix}

    ${chart_path}=    Set Variable    ${CURDIR}/../test_workloads/simple-job

    Set Test Variable    ${TEST_WORKLOAD_RELEASE_NAME}    ${release_name}
    Set Test Variable    ${TEST_WORKLOAD_CHART_PATH}    ${chart_path}
    Set Test Variable    ${TEST_WORKLOAD_CPU_LIMIT}    ${cpu_limit}
    Set Test Variable    ${TEST_WORKLOAD_TYPE}    cpu-limited

A workload with memory quota "${memory_limit}" is prepared
    [Documentation]    Prepares a workload with specific memory resource requirements
    ${unique_suffix}=    Generate Random String    6    [LOWER][NUMBERS]
    ${release_name}=    Set Variable    test-mem-${unique_suffix}

    ${chart_path}=    Set Variable    ${CURDIR}/../test_workloads/simple-job

    Set Test Variable    ${TEST_WORKLOAD_RELEASE_NAME}    ${release_name}
    Set Test Variable    ${TEST_WORKLOAD_CHART_PATH}    ${chart_path}
    Set Test Variable    ${TEST_WORKLOAD_MEMORY_LIMIT}    ${memory_limit}
    Set Test Variable    ${TEST_WORKLOAD_TYPE}    memory-limited

A GPU workload is prepared
    [Documentation]    Prepares a GPU test workload configuration
    [Arguments]    ${gpu_count}=2
    ${unique_suffix}=    Generate random string    6    [LOWER][NUMBERS]
    ${release_name}=    Set variable    test-gpu-${unique_suffix}
    ${chart_path}=    Set variable    ${CURDIR}/../test_workloads/gpu-job

    Set test variable    ${TEST_WORKLOAD_RELEASE_NAME}    ${release_name}
    Set test variable    ${TEST_WORKLOAD_CHART_PATH}    ${chart_path}
    Set test variable    ${TEST_WORKLOAD_GPU_COUNT}    ${gpu_count}
    Set test variable    ${TEST_WORKLOAD_TYPE}    gpu-job

# When keywords - Actions

Test workload is submitted via helm
    [Documentation]    Submits a test workload via helm to project namespace
    ...    Polls AIRM API until workload appears (async detection)
    ...    Returns the workload ID for tracking

    # Set TEST_NAMESPACE to the current project's namespace (slug)
    Set Test Variable    ${TEST_NAMESPACE}    ${TEST_PROJECT_SLUG}

    ${values}=    Create Dictionary

    IF    '${TEST_WORKLOAD_TYPE}' == 'gpu-job'
        Set To Dictionary    ${values}    resources.requests.amd\.com/gpu=${TEST_WORKLOAD_GPU_COUNT}
        Set To Dictionary    ${values}    resources.limits.amd\.com/gpu=${TEST_WORKLOAD_GPU_COUNT}
    ELSE IF    '${TEST_WORKLOAD_TYPE}' == 'cpu-limited'
        Set To Dictionary    ${values}    resources.requests.cpu=${TEST_WORKLOAD_CPU_LIMIT}
        Set To Dictionary    ${values}    resources.limits.cpu=${TEST_WORKLOAD_CPU_LIMIT}
    ELSE IF    '${TEST_WORKLOAD_TYPE}' == 'memory-limited'
        Set To Dictionary    ${values}    resources.requests.memory=${TEST_WORKLOAD_MEMORY_LIMIT}
        Set To Dictionary    ${values}    resources.limits.memory=${TEST_WORKLOAD_MEMORY_LIMIT}
    END

    ${release_name}=    Install workload via helm
    ...    ${TEST_WORKLOAD_CHART_PATH}
    ...    ${TEST_WORKLOAD_RELEASE_NAME}
    ...    ${TEST_NAMESPACE}
    ...    ${values}

    Append To List    ${CREATED_HELM_RELEASES}    ${release_name}:::${TEST_NAMESPACE}
    Log    Submitted workload ${release_name} to namespace ${TEST_NAMESPACE}    INFO

    # Wait for workload to appear in AIRM (sets TEST_WORKLOAD_ID)
    Wait Until Keyword Succeeds    2 min    5 sec
    ...    Find workload in AIRM API    ${release_name}

    # Return the workload ID
    RETURN    ${TEST_WORKLOAD_ID}

Find workload in AIRM API
    [Documentation]    Find workload by release name in AIRM API (used with polling)
    ...    Matches workloads by display_name field (primary) based on API schema
    [Arguments]    ${release_name}

    Log    Polling for workload ${release_name} in AIRM API    TRACE
    ${response}=    Get workloads    expected_status=200
    ${workloads}=    Set Variable    ${response.json()['data']}

    FOR    ${workload}    IN    @{workloads}
        ${workload_id}=    Get From Dictionary    ${workload}    id
        ${display_name}=    Get From Dictionary    ${workload}    display_name    default=${EMPTY}

        # Match by display_name (this is the correct field per API schema)
        IF    '${display_name}' == '${release_name}'
            Set Test Variable    ${TEST_WORKLOAD_ID}    ${workload_id}
            Append To List    ${CREATED_WORKLOAD_IDS}    ${workload_id}
            Log    Discovered workload ${release_name} in AIRM API with ID: ${workload_id}    INFO
            RETURN
        END
    END

    FAIL    Workload ${release_name} not found in AIRM API yet

Workload is deleted via kubectl
    [Documentation]    Deletes workload via helm uninstall
    ...    Polls AIRM API until workload status is "Deleted" or 404
    Log    Deleting workload ${TEST_WORKLOAD_RELEASE_NAME} via helm    DEBUG
    ${success}=    Uninstall workload via helm    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}

    Should Be True    ${success}    msg=Failed to uninstall helm release

    Wait Until Keyword Succeeds    1 min    3 sec
    ...    Verify workload deleted in AIRM
    Log    Deleted workload ${TEST_WORKLOAD_ID} via kubectl    INFO

Verify workload deleted in AIRM
    [Documentation]    Verify workload is deleted in AIRM API (used with polling)
    Log    Polling for workload ${TEST_WORKLOAD_ID} deletion status    TRACE
    TRY
        ${response}=    Get workload    ${TEST_WORKLOAD_ID}    expected_status=any
        IF    ${response.status_code} == 404
            RETURN
        END
        ${status}=    Set Variable    ${response.json()['status']}
        Should Be Equal    ${status}    Deleted    msg=Workload not deleted yet: ${status}
    EXCEPT
        Log    Workload ${TEST_WORKLOAD_ID} not found (deleted)    DEBUG
    END

Workload is terminated
    [Documentation]    Terminates a running workload by deleting it
    Workload is deleted via kubectl

# Then keywords - Assertions

Workload status in AIRM should be "${expected_status}"
    [Documentation]    Verifies workload status matches expected value
    ...    Polls GET /workloads/{id} with periodic intervals
    Wait Until Keyword Succeeds    1 min    2 sec
    ...    Verify workload status in AIRM    ${expected_status}

Verify workload status in AIRM
    [Documentation]    Helper to verify workload status (used with polling)
    [Arguments]    ${expected_status}    ${workload_id}=${None}

    ${id}=    Set Variable If    '${workload_id}' != '${None}'    ${workload_id}    ${TEST_WORKLOAD_ID}

    ${response}=    Get workload    ${id}    expected_status=200
    ${actual_status}=    Set Variable    ${response.json()['status']}

    Log    Polling workload ${id} status: ${actual_status}    TRACE
    Should Be Equal    ${actual_status}    ${expected_status}
    ...    msg=Expected status ${expected_status}, got ${actual_status}
    Log    Workload ${id} status is ${expected_status}    INFO

Workload status should transition to "${expected_status}"
    [Documentation]    Waits for workload to transition to expected status
    ...    Timeout reduced to 90 sec - workload transitions are typically fast
    [Arguments]    ${workload_id}=${None}

    ${id}=    The workload    id=${workload_id}

    Wait Until Keyword Succeeds    90 sec    3 sec
    ...    Verify workload status in AIRM    ${expected_status}    ${id}

Workload should be preempted
    [Documentation]    Verifies workload was preempted/suspended
    ...    Waits for preemption to occur as it may take time for K8s to react
    [Arguments]    ${workload_id}=${None}    ${timeout}=2 min

    ${id}=    The workload    id=${workload_id}

    # Wait for workload to be preempted - give K8s time to react to quota pressure
    Wait Until Keyword Succeeds    ${timeout}    5 sec
    ...    Verify workload is preempted    ${id}

Verify workload is preempted
    [Documentation]    Helper to verify workload has been preempted
    [Arguments]    ${workload_id}

    ${response}=    Get workload    ${workload_id}    expected_status=200
    ${status}=    Set variable    ${response.json()['status']}
    Log    Checking workload ${workload_id} preemption status: ${status}    DEBUG

    # Preempted workloads should be Pending (waiting for resources)
    Should be true    '${status}' in ['Preempted', 'Suspended', 'Pending']
    ...    msg=Expected workload to be preempted but status is ${status}

Workload should be pending due to quota
    [Documentation]    Verifies workload is pending in AIRM due to quota enforcement
    ...    NOTE: We use AIRM API verification here because the test user doesn't have
    ...    permissions to query K8s resources directly (ResourceQuotas, Pod conditions, etc.)
    ...    The AIRM service monitors K8s quota enforcement and reflects it in workload status

    Wait Until Keyword Succeeds    1 min    2 sec
    ...    Verify workload status in AIRM    Pending

Workload should exist in AIRM
    [Documentation]    Verifies workload exists in AIRM API
    ...    First discovers the workload by release name, then verifies it exists
    ...    NOTE: Extended timeout to allow for AIRM auto-discovery latency
    [Arguments]    ${workload_id}=${None}

    Wait Until Keyword Succeeds    3 min    1 sec
    ...    Find workload in AIRM API    ${TEST_WORKLOAD_RELEASE_NAME}
    Wait Until Keyword Succeeds    1 min    2 sec
    ...    Verify workload exists    ${workload_id}

Verify workload exists
    [Documentation]    Helper to verify workload exists (used with polling)
    [Arguments]    ${workload_id}=${None}

    ${id}=    The workload    id=${workload_id}

    Log    Polling for workload ${id} existence    TRACE
    ${response}=    Get workload    ${id}    expected_status=200
    Dictionary Should Contain Key    ${response.json()}    id
    Dictionary Should Contain Key    ${response.json()}    status
    Log    Verified workload ${id} exists    DEBUG

Workload should not exist in AIRM
    [Documentation]    Verifies workload does not exist in AIRM API
    Wait Until Keyword Succeeds    1 min    2 sec
    ...    Verify workload not found
    Log    Verified workload ${TEST_WORKLOAD_ID} does not exist    INFO

Verify workload not found
    [Documentation]    Helper to verify workload doesn't exist (used with polling)
    Log    Polling for workload ${TEST_WORKLOAD_ID} non-existence    TRACE
    ${response}=    Get workload    ${TEST_WORKLOAD_ID}    expected_status=404

# Cleanup keywords
# MOVED TO resource_tracking.resource - Commented out to avoid duplicate keyword
# Clean Up All Created Workloads
#     [Documentation]    Deletes all workloads created during test execution
#     ...    Extends the basic cleanup from resource_tracking.resource
#     ...    by also handling helm releases
#     ${workload_count}=    Get Length    ${CREATED_WORKLOAD_IDS}
#     ${release_count}=    Get Length    ${CREATED_HELM_RELEASES}
#
#     Log    Cleaning up ${release_count} helm releases and ${workload_count} AIRM workloads    INFO
#
#     FOR    ${release_info}    IN    @{CREATED_HELM_RELEASES}
#         ${parts}=    Split String    ${release_info}    :::
#         ${release_name}=    Get From List    ${parts}    0
#         ${namespace}=    Get From List    ${parts}    1
#
#         TRY
#             Log    Deleting helm release ${release_name} in namespace ${namespace}    DEBUG
#             Uninstall workload via helm    ${release_name}    ${namespace}
#             Log    Deleted helm release ${release_name}    INFO
#         EXCEPT    AS    ${error}
#             Log    Failed to delete helm release ${release_name}: ${error}    WARN
#         END
#     END
#
#     Clean Up All Created Workloads Via API
#
#     @{empty_releases}=    Create List
#     Set Suite Variable    ${CREATED_HELM_RELEASES}    ${empty_releases}
#     Log    Workload cleanup complete    INFO

# Kubernetes Resource Verification Keywords

Job should exist in project namespace
    [Documentation]    Verifies that the workload Job exists in the project namespace
    ...    This is the PRIMARY verification - the actual K8s resource must exist
    ${job}=    Job should exist in namespace    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}
    Log    Job ${TEST_WORKLOAD_RELEASE_NAME} exists in namespace ${TEST_NAMESPACE}    INFO
    RETURN    ${job}

Deployment should exist in project namespace
    [Documentation]    Verifies that the workload Deployment exists in the project namespace
    ${deployment}=    Deployment should exist in namespace    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}
    Log    Deployment ${TEST_WORKLOAD_RELEASE_NAME} exists in namespace ${TEST_NAMESPACE}    INFO
    RETURN    ${deployment}

Pod should exist for Job
    [Documentation]    Verifies that a Pod was created for the Job
    ${pod}=    kubectl_verification.Pod should exist for Job    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}
    Log    Pod exists for Job ${TEST_WORKLOAD_RELEASE_NAME}    INFO
    RETURN    ${pod}

Pod should exist for Deployment
    [Documentation]    Verifies that Pods were created for the Deployment
    ${pods}=    kubectl_verification.Pods should exist for Deployment    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}
    ${count}=    Get Length    ${pods}
    Log    ${count} Pod(s) exist for Deployment ${TEST_WORKLOAD_RELEASE_NAME}    INFO
    RETURN    ${pods}

Pod should transition to "Running"
    [Documentation]    Waits for the Job Pod to reach Running status
    kubectl_verification.Wait for Pod status    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}    Running    timeout=2 min
    Log    Pod for Job ${TEST_WORKLOAD_RELEASE_NAME} is Running    INFO

Deployment Pod should transition to "Running"
    [Documentation]    Waits for at least one Deployment Pod to reach Running status
    kubectl_verification.Wait for Deployment Pod status    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}    Running    timeout=2 min
    Log    At least one Pod for Deployment ${TEST_WORKLOAD_RELEASE_NAME} is Running    INFO

Job should complete successfully
    [Documentation]    Waits for the Job to complete successfully
    kubectl_verification.Job should complete successfully    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}    timeout=5 min
    Log    Job ${TEST_WORKLOAD_RELEASE_NAME} completed successfully    INFO

Job should fail
    [Documentation]    Waits for the Job to fail
    kubectl_verification.Job should fail    ${TEST_WORKLOAD_RELEASE_NAME}    ${TEST_NAMESPACE}    timeout=5 min
    Log    Job ${TEST_WORKLOAD_RELEASE_NAME} failed as expected    INFO

Workload SHOULD be discovered by AIRM
    [Documentation]    Verifies workload is discovered by AIRM (informational/secondary check)
    ...    This tests the auto-discovery mechanism, which is separate from K8s resource creation.
    ...    Tests will not fail if discovery doesn't work - that's logged as a warning.
    TRY
        Wait Until Keyword Succeeds    1 min    5 sec
        ...    Find workload in AIRM API    ${TEST_WORKLOAD_RELEASE_NAME}
        Log    SUCCESS: Workload discovered by AIRM auto-discovery mechanism    INFO
    EXCEPT
        Log    WARNING: Workload NOT discovered by AIRM (auto-discovery issue - separate bug)    WARN
        Log    This is informational only - K8s resource verification is what matters    WARN
    END
